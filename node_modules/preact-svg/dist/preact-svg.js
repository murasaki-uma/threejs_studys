(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('preact')) :
	typeof define === 'function' && define.amd ? define(['preact'], factory) :
	(global.preactSvg = factory(global.preact));
}(this, function (preact) { 'use strict';

	var babelHelpers = {};

	babelHelpers.classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	babelHelpers.extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	babelHelpers.inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	babelHelpers.objectWithoutProperties = function (obj, keys) {
	  var target = {};

	  for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;
	    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
	    target[i] = obj[i];
	  }

	  return target;
	};

	babelHelpers.possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	babelHelpers;

	var DOM = typeof document !== 'undefined' && !!document.createElement;

	var SVG_ATTRS = ['viewBox'];

	var NS = {
		xlink: 'http://www.w3.org/1999/xlink'
	};

	var NS_ATTR = /^([a-zA-Z]+)(?:\:|([A-Z]))/;

	var PROP_TO_ATTR_MAP = {
		'className': 'class'
	};

	var EMPTY = {};

	var updateMode = false;

	if (DOM) {
		(function () {
			var div = document.createElement('div');

			var oldCreate = document.createElement;
			document.createElement = function (name) {
				if (updateMode || name === 'svg') {
					var el = document.createElementNS('http://www.w3.org/2000/svg', name);

					el.setAttribute = createAttributeShim('setAttribute');
					el.getAttribute = createAttributeShim('getAttribute');
					el.removeAttribute = createAttributeShim('removeAttribute');
					for (var key in el) {
						if (~SVG_ATTRS.indexOf(key) || !(key in div) || PROP_TO_ATTR_MAP.hasOwnProperty(key)) {
							overwriteProperty(el, key);
						}
					}
					return el;
				}
				return oldCreate.call(document, name);
			};
		})();
	}

	var PROPERTY_ERRORS = {};
	var hasPropertyErrors = false;

	function overwriteProperty(el, key) {
		var err = PROPERTY_ERRORS[key];
		if (err === false) {
			Object.defineProperty(el, key, contentPropertyDef(key));
		} else {
			attemptOverwriteProperty(el, key);
		}
	}

	function attemptOverwriteProperty(el, key) {
		try {
			Object.defineProperty(el, key, contentPropertyDef(key));
			PROPERTY_ERRORS[key] = false;
		} catch (e) {
			if (!PROPERTY_ERRORS[key]) {
				var err = el.nodeName + ': ' + e;
				PROPERTY_ERRORS[key] = err;
				if (!hasPropertyErrors && 'undefined' !== typeof console && console.warn) {
					hasPropertyErrors = true;
					console.warn('Error overwriting some SVG properties.', { errors: PROPERTY_ERRORS });
				}
			}
		}
	}

	var memoize = function (fn) {
		var mem = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
		return function (k) {
			return mem.hasOwnProperty(k) ? mem[k] : mem[k] = fn(k);
		};
	};

	var contentPropertyDef = memoize(function (prop) {
		var attr = arguments.length <= 1 || arguments[1] === undefined ? PROP_TO_ATTR_MAP[prop] || prop : arguments[1];
		return {
			set: function (v) {
				if (v === null || v === undefined) this.removeAttribute(attr);else this.setAttribute(attr, v);
			},
			get: function () {
				return this.getAttribute(attr);
			}
		};
	});

	var createAttributeShim = memoize(function (method) {
		return function (name, value) {
			var proto = this.constructor.prototype,
			    p = name.match(NS_ATTR);
			if (p && NS.hasOwnProperty(p[1])) {
				name = name.replace(NS_ATTR, '$2').toLowerCase();
				var ns = NS[p[1]];
				return proto[method + 'NS'].call(this, ns, name, value);
			} else {
				return proto[method].call(this, name, value);
			}
		};
	});

	var SVG = function (_Component) {
		babelHelpers.inherits(SVG, _Component);

		function SVG() {
			babelHelpers.classCallCheck(this, SVG);
			return babelHelpers.possibleConstructorReturn(this, _Component.apply(this, arguments));
		}

		SVG.prototype.componentWillUpdate = function componentWillUpdate() {
			updateMode = true;
		};

		SVG.prototype.componentDidUpdate = function componentDidUpdate() {
			updateMode = false;
		};

		SVG.prototype.render = function render(_ref) {
			var children = _ref.children;
			var props = babelHelpers.objectWithoutProperties(_ref, ['children']);

			if (!this.hasRendered) {
				this.hasRendered = updateMode = true;

				this.setState(EMPTY, setStateUpdateProxy(this));
			}

			return preact.h(
				'svg',
				babelHelpers.extends({ version: '1.1', xmlns: 'http://www.w3.org/2000/svg' }, props),
				children
			);
		};

		return SVG;
	}(preact.Component);

	function setStateUpdateProxy(component) {
		return function () {
			component.componentDidUpdate();
			component = null;
		};
	}

	return SVG;

}));
//# sourceMappingURL=preact-svg.js.map