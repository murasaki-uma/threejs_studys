
<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometries</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>

<script src="./js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="./js/Detector.js"></script>
<script src="./js/stats.min.js"></script>

<script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    var container, stats;

    var camera, scene, renderer;

    var body,leg,legRight,armLeft,armRight,head,doll;

    init();
    animate();

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 15000 );
        camera.position.y = 0;
        camera.position.z =1000;

        //camera.lookAt(new THREE.Vector3(0,200,0))

        scene = new THREE.Scene();

        var light, object;

        scene.add( new THREE.AmbientLight( 0x404040 ) );

        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 1, 0 );
        scene.add( light );

//        var map = new THREE.TextureLoader().load( 'textures/UV_Grid_Sm.jpg' );
//        map.wrapS = map.wrapT = THREE.RepeatWrapping;
//        map.anisotropy = 16;

        var material = new THREE.MeshPhongMaterial(
                    {
                        color: 0xffffff,
                        side: THREE.DoubleSide,
                        wireframe:true,
                        wireframeLinewidth:0.5
                    }
                );

        //

//        object = new THREE.Mesh( new THREE.SphereGeometry( 75, 20, 10 ), material );
//        object.position.set( -400, 0, 200 );
//        scene.add( object );
//
//        object = new THREE.Mesh( new THREE.IcosahedronGeometry( 75, 1 ), material );
//        object.position.set( -200, 0, 200 );
//        scene.add( object );

        object = new THREE.Mesh( new THREE.OctahedronGeometry( 30, 2 ), material );
        object.position.set( 0, 110, 0 );
        scene.add( object );


        object = new THREE.Mesh( new THREE.OctahedronGeometry( 70, 2 ), material );
        object.position.set( 0, 0, 0 );
        scene.add( object );

//        object = new THREE.Mesh( new THREE.OctahedronGeometry( 30, 2 ), material );
//        object.position.set( 0, -100, 0 );
//        scene.add( object );

        // 左腕

        object = new THREE.Mesh( new THREE.OctahedronGeometry( 20, 2 ), material );
        object.position.set( -90, 40, 0 );
        scene.add( object );

        object = new THREE.Mesh( new THREE.OctahedronGeometry( 20, 2 ), material );
        object.position.set( -120, -30, 0 );
        scene.add( object );


        object = new THREE.Mesh( new THREE.OctahedronGeometry( 15, 2 ), material );
        object.position.set( -130, -80, 0 );
        scene.add( object );

        // 右腕
        object = new THREE.Mesh( new THREE.OctahedronGeometry( 20, 2 ), material );
        object.position.set( 90, 40, 0 );
        scene.add( object );

        object = new THREE.Mesh( new THREE.OctahedronGeometry( 20, 2 ), material );
        object.position.set( 120, -30, 0 );
        scene.add( object );


        object = new THREE.Mesh( new THREE.OctahedronGeometry( 15, 2 ), material );
        object.position.set( 130, -80, 0 );
        scene.add( object );


        // 左足
        object = new THREE.Mesh( new THREE.OctahedronGeometry( 30, 2 ), material );
        object.position.set( -40, -100, 0 );
        scene.add( object );


        object = new THREE.Mesh( new THREE.OctahedronGeometry( 20, 2 ), material );
        object.position.set( -70, -180, 0 );
        scene.add( object );

        object = new THREE.Mesh( new THREE.OctahedronGeometry( 15, 2 ), material );
        object.position.set( -80, -260, 0 );
        scene.add( object );


        // 右足
        object = new THREE.Mesh( new THREE.OctahedronGeometry( 30, 2 ), material );
        object.position.set( 40, -100, 0 );
        scene.add( object );


        object = new THREE.Mesh( new THREE.OctahedronGeometry( 20, 2 ), material );
        object.position.set( 70, -180, 0 );
        scene.add( object );

        object = new THREE.Mesh( new THREE.OctahedronGeometry( 15, 2 ), material );
        object.position.set( 80, -260, 0 );
        scene.add( object );






        var _material = new THREE.MeshPhongMaterial(
                {
                    color: "rgb(100,２00,100)",
                    opacity: 0.1,
                    blending:THREE[ "AdditiveBlending" ],
                    side: THREE.DoubleSide,
                    wireframe:true,
                    side:THREE.FrontSide
                }
        );


        object = new THREE.Mesh( new THREE.PlaneGeometry( 2000,2000,30,30 ), _material );
        object.position.set( 0, 0, 0 );
        object.rotateX(180);
        //scene.add( object );



        //

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        window.addEventListener( 'resize', onWindowResize, false );
        controls = new THREE.OrbitControls( camera, container );

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    function render() {

        var timer = Date.now() * 0.0001;

//        camera.position.x = Math.cos( timer ) * 800;
//        camera.position.z = Math.sin( timer ) * 800;

        camera.lookAt( scene.position );

//        for ( var i = 0, l = scene.children.length; i < l; i ++ ) {
//
//            var object = scene.children[ i ];
//
//            object.rotation.x = timer * 5;
//            object.rotation.y = timer * 2.5;
//
//        }

        renderer.render( scene, camera );

    }

</script>

</body>
</html>
